library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity uart_tb is
end entity uart_tb;

architecture tb of uart_tb is
    component uart is
        generic (
            input_clock_frequency : natural := 10e6;
            baudrate : natural := 10e5
        );
        port (
            data_in: in std_logic_vector(7 downto 0);
            tx_start, clk: in std_logic;
            uart_rx_line : in std_logic;
            uart_tx_line : out std_logic;
            tx_busy, rx_busy, tx_done, rx_done : out std_logic;
            data_out : out std_logic_vector(7 downto 0);
            tx_count : out std_logic_vector(7 downto 0)
        );
    end component;

    signal data_in_tb: std_logic_vector(7 downto 0) := x"00";
    signal clk_tb: std_logic := '0';
    signal tx_start_tb : std_logic := '1';
    signal uart_rx_line_tb : std_logic := '1';
    signal uart_tx_line_tb : std_logic := '1';
    signal tx_busy_tb, rx_busy_tb, tx_done_tb, rx_done_tb : std_logic := '1';
    signal data_out_tb : std_logic_vector(7 downto 0) := x"00";
    signal tx_count_tb : std_logic_vector(7 downto 0) := x"00";

    signal loop_signal_tb : std_logic;

begin
    
    loop_signal_tb <= uart_tx_line_tb;

    DUT : uart
    port map (
        data_in_tb, tx_start_tb, clk_tb, loop_signal_tb, uart_tx_line_tb, tx_busy_tb, rx_busy_tb, tx_done_tb, rx_done_tb, data_out_tb, tx_count_tb
    );

    clock_gen : process is
    begin
        wait for 50 ps;
        clk_tb <= not clk_tb;
    end process;


    process (tx_done_tb) is
    begin
        if (tx_done_tb'event and tx_done_tb = '1') then
            tx_start_tb <= '0';
        end if;
    end process;

    
end architecture tb;