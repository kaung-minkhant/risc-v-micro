library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity uart_tx is
    generic (
        count_per_bit: natural := 20 -- clock per bit
    );
    port (
        clk, send : in std_logic;
        data_in : in std_logic_vector(7 downto 0);
        tx_busy, tx, tx_done : out std_logic;
        tx_count: out std_logic_vector(7 downto 0)
    );
end entity uart_tx;

architecture rtl of uart_tx is
    signal data_full : std_logic_vector(9 downto 0);
    signal tx_flag : std_logic := '0';

    signal index : integer range 0 to 9 := 0;
    
    signal count : integer := 0;
    constant HALF_BIT_COUNT : natural := (count_per_bit-1)/2;
    constant FULL_BIT_COUNT : natural := count_per_bit - 1;
begin
    
    process (clk) is
    begin
        if (clk'event and clk = '1') then
            if (tx_flag = '0') then
                tx_done <= '0';
            end if;
            if (tx_flag = '0' and send = '1') then
                tx_flag <= '1';
                data_full <= '1' & data_in & '0';
            end if;

            if (tx_flag = '1') then
                tx_busy <= '1';
                tx_done <= '0';
                if (count <= FULL_BIT_COUNT) then
                    count <= count + 1;
                else 
                    count <= 0;
                end if;

                if (count = HALF_BIT_COUNT) then
                    tx <= data_full(index);
                    if (index < 9) then
                        index <= index + 1;
                    else 
                        index <= 0;
                        tx_flag <= '0';
                        tx_busy <= '0';
                        tx_done <= '1';
                    end if;
                end if;
            else
                tx_busy <= '0';
                tx <= '1';
            end if;

        end if;
    end process;

    tx_count <= std_logic_vector(to_unsigned(count, 8));
    
end architecture rtl;