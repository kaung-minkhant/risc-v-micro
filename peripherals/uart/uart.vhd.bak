library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity uart is
    generic (
        input_clock_frequency : natural := 10e6;
        baudrate : natural := 10e5
    );
    port (
        data_in: in std_logic_vector(7 downto 0);
        tx_start, clk: in std_logic;
        uart_rx_line : in std_logic;
        uart_tx_line : out std_logic;
        tx_busy, rx_busy, tx_done, rx_done : out std_logic;
        data_out : out std_logic_vector(7 downto 0);
        tx_count : out std_logic_vector(7 downto 0)
    );
end entity uart;

architecture rtl of uart is
    constant count_per_bit : natural := input_clock_frequency/baudrate;
    component uart_tx is
        generic (
            count_per_bit: natural := 20 -- clock per bit
        );
        port (
            clk, send : in std_logic;
            data_in : in std_logic_vector(7 downto 0);
            tx_busy, tx, tx_done : out std_logic;
            tx_count: out std_logic_vector(7 downto 0)
        );
    end component;

    component uart_rx is
        generic (
            count_per_bit: natural := 20 -- clock per bit
        );
        port (
            rx, clk: in std_logic;
            data_out: out std_logic_vector(7 downto 0);
            rx_busy, rx_done: out std_logic
        );
    end component;
begin
    
    tx_u : uart_tx
        generic map (
            count_per_bit => count_per_bit
        )
        port map (
            clk => clk, send => tx_start, data_in => data_in,
            tx_busy => tx_busy, tx => uart_tx_line, tx_done => tx_done, tx_count => tx_count
        );
    
    rx_u : uart_rx
        generic map (
            count_per_bit => count_per_bit
        )
        port map (
            rx => uart_rx_line, clk => clk, data_out => data_out,
            rx_busy => rx_busy, rx_done => rx_done 
        );
    
end architecture rtl;